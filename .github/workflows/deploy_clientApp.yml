name: Deploy Client Application

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - stage
          - prod

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: windows-latest
    environment: ${{ github.event.inputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_TERRAFORM_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get Key Vault URL
        id: get-keyvault
        run: |
          $kvUrl = az keyvault show `
            --name "kv-megabks-trn-mgr-${{ github.event.inputs.environment }}" `
            --resource-group "rg-trn-mgr-${{ github.event.inputs.environment }}" `
            --query "properties.vaultUri" `
            --output tsv
          
          echo "KEYVAULT_URL=$kvUrl" >> $env:GITHUB_ENV
          Write-Host "Key Vault URL: $kvUrl"

      - name: Update appsettings.json
        working-directory: source/main
        run: |
          Write-Host "Updating appsettings.json with Key Vault URL: $env:KEYVAULT_URL"
          
          $appSettings = Get-Content appsettings.json | ConvertFrom-Json
          $appSettings.KeyVaultConfig.VaultUrl = $env:KEYVAULT_URL
          
          $appSettings | ConvertTo-Json -Depth 10 | Set-Content appsettings.json
          
          Write-Host "Updated appsettings.json:"
          Get-Content appsettings.json

      - name: Build application
        working-directory: source/main
        run: |
          dotnet build BowlingMegabucks.TournamentManager.csproj -c Release

      - name: Get application version
        id: get-version
        working-directory: source/main
        run: |
          [xml]$csproj = Get-Content BowlingMegabucks.TournamentManager.csproj
          $version = $csproj.Project.PropertyGroup.VersionPrefix | Where-Object { $_ -ne $null } | Select-Object -First 1
          echo "VERSION=$version" >> $env:GITHUB_ENV
          Write-Host "Application version: $version"

      - name: Publish ClickOnce
        working-directory: source/main
        env:
          INSTALL_URL: ${{ vars.CLICKONCE_INSTALL_URL }}
        run: |
          # Create a publish profile for ClickOnce
          $profileDir = "Properties\PublishProfiles"
          New-Item -ItemType Directory -Force -Path $profileDir | Out-Null
          
          $xml = New-Object System.Xml.XmlDocument
          $project = $xml.CreateElement("Project")
          $propertyGroup = $xml.CreateElement("PropertyGroup")
          
          $elements = @{
            "PublishProtocol" = "ClickOnce"
            "Configuration" = "Release"
            "Platform" = "Any CPU"
            "TargetFramework" = "net9.0-windows"
            "PublishDir" = "publish\"
            "PublishUrl" = $env:INSTALL_URL
            "InstallUrl" = $env:INSTALL_URL
            "ApplicationVersion" = "$($env:VERSION).0"
            "UpdateEnabled" = "true"
            "UpdateMode" = "Foreground"
            "UpdateInterval" = "7"
            "UpdateIntervalUnits" = "Days"
            "UpdatePeriodically" = "false"
            "UpdateRequired" = "false"
            "MapFileExtensions" = "true"
            "CreateWebPageOnPublish" = "true"
            "WebPage" = "publish.html"
            "ApplicationRevision" = "0"
            "IsWebBootstrapper" = "true"
            "BootstrapperEnabled" = "true"
            "PublisherName" = "Bowling Megabucks"
            "ProductName" = "Tournament Manager"
          }
          
          foreach ($key in $elements.Keys) {
            $element = $xml.CreateElement($key)
            $element.InnerText = $elements[$key]
            $propertyGroup.AppendChild($element) | Out-Null
          }
          
          $project.AppendChild($propertyGroup) | Out-Null
          $xml.AppendChild($project) | Out-Null
          $xml.Save("$profileDir\ClickOnceProfile.pubxml")
          
          # Publish using the profile
          dotnet publish BowlingMegabucks.TournamentManager.csproj /p:PublishProfile=ClickOnceProfile /p:Configuration=Release
          
          Write-Host "ClickOnce files generated:"
          Get-ChildItem -Path publish -Recurse -File | Select-Object FullName

      - name: Deploy to FTP Server
        working-directory: source/main/publish
        env:
          FTP_SERVER: ${{ vars.FTP_SERVER }}
          FTP_USERNAME: ${{ secrets.FTP_USERNAME }}
          FTP_PASSWORD: ${{ secrets.FTP_PASSWORD }}
          FTP_FOLDER: ${{ vars.FTP_FOLDER }}
        run: |
          Write-Host "Deploying to FTP Server: $env:FTP_SERVER"
          Write-Host "Target folder: $env:FTP_FOLDER"
          
          # Function to upload file via FTP
          function Upload-FileToFtp {
              param(
                  [string]$LocalPath,
                  [string]$RemotePath,
                  [string]$FtpServer,
                  [string]$Username,
                  [string]$Password
              )
              
              $ftpUri = "ftp://$FtpServer/$RemotePath"
              Write-Host "Uploading: $LocalPath -> $ftpUri"
              
              $ftpRequest = [System.Net.FtpWebRequest]::Create($ftpUri)
              $ftpRequest.Method = [System.Net.WebRequestMethods+Ftp]::UploadFile
              $ftpRequest.Credentials = New-Object System.Net.NetworkCredential($Username, $Password)
              $ftpRequest.UseBinary = $true
              $ftpRequest.UsePassive = $true
              $ftpRequest.KeepAlive = $false
              
              $fileContent = [System.IO.File]::ReadAllBytes($LocalPath)
              $ftpRequest.ContentLength = $fileContent.Length
              
              $requestStream = $ftpRequest.GetRequestStream()
              $requestStream.Write($fileContent, 0, $fileContent.Length)
              $requestStream.Close()
              
              $response = $ftpRequest.GetResponse()
              Write-Host "Upload completed: $($response.StatusDescription)"
              $response.Close()
          }
          
          # Function to create directory via FTP
          function Create-FtpDirectory {
              param(
                  [string]$RemotePath,
                  [string]$FtpServer,
                  [string]$Username,
                  [string]$Password
              )
              
              try {
                  $ftpUri = "ftp://$FtpServer/$RemotePath"
                  Write-Host "Creating directory: $ftpUri"
                  $ftpRequest = [System.Net.FtpWebRequest]::Create($ftpUri)
                  $ftpRequest.Method = [System.Net.WebRequestMethods+Ftp]::MakeDirectory
                  $ftpRequest.Credentials = New-Object System.Net.NetworkCredential($Username, $Password)
                  $ftpRequest.UsePassive = $true
                  $ftpRequest.KeepAlive = $false
                  
                  $response = $ftpRequest.GetResponse()
                  Write-Host "✓ Directory created: $RemotePath"
                  $response.Close()
              }
              catch [System.Net.WebException] {
                  $response = $_.Exception.Response
                  if ($response) {
                      $statusCode = [int]$response.StatusCode
                      # 550 = Directory already exists, which is fine
                      if ($statusCode -eq 550) {
                          Write-Host "✓ Directory already exists: $RemotePath"
                      } else {
                          Write-Host "Warning: Could not create directory $RemotePath - $($_.Exception.Message)"
                      }
                  }
              }
              catch {
                  Write-Host "Warning: Could not create directory $RemotePath - $($_.Exception.Message)"
              }
          }
          
          # Function to ensure full directory path exists
          function Ensure-FtpDirectoryPath {
              param(
                  [string]$RemotePath,
                  [string]$FtpServer,
                  [string]$Username,
                  [string]$Password
              )
              
              # Skip if already processed
              if ($script:createdDirectories -contains $RemotePath) {
                  return
              }
              
              $parts = $RemotePath.Split('/', [StringSplitOptions]::RemoveEmptyEntries)
              $currentPath = ""
              
              foreach ($part in $parts) {
                  if ($currentPath) {
                      $currentPath += "/$part"
                  } else {
                      $currentPath = $part
                  }
                  
                  # Skip if already created
                  if ($script:createdDirectories -contains $currentPath) {
                      continue
                  }
                  
                  Create-FtpDirectory -RemotePath $currentPath -FtpServer $FtpServer -Username $Username -Password $Password
                  $script:createdDirectories += $currentPath
              }
          }
          
          # Cache for created directories
          $script:createdDirectories = @()
          
          # Create target directory
          Ensure-FtpDirectoryPath -RemotePath $env:FTP_FOLDER -FtpServer $env:FTP_SERVER -Username $env:FTP_USERNAME -Password $env:FTP_PASSWORD
          
          # Upload all files
          $files = Get-ChildItem -Recurse -File
          $totalFiles = $files.Count
          $currentFile = 0
          
          foreach ($file in $files) {
              $currentFile++
              $relativePath = $file.FullName.Substring((Get-Location).Path.Length + 1).Replace('\', '/')
              $remotePath = "$env:FTP_FOLDER/$relativePath"
              
              # Create subdirectories if needed
              $remoteDir = ($remotePath -replace '\\', '/').Substring(0, $remotePath.LastIndexOf('/'))
              if ($remoteDir -and $remoteDir -ne $env:FTP_FOLDER) {
                  Ensure-FtpDirectoryPath -RemotePath $remoteDir -FtpServer $env:FTP_SERVER -Username $env:FTP_USERNAME -Password $env:FTP_PASSWORD
              }
              
              Write-Host "[$currentFile/$totalFiles] Uploading $relativePath"
              Upload-FileToFtp -LocalPath $file.FullName -RemotePath $remotePath -FtpServer $env:FTP_SERVER -Username $env:FTP_USERNAME -Password $env:FTP_PASSWORD
          }
          
          Write-Host "Upload successful! Deployed $totalFiles files."
