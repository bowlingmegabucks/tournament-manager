name: Deploy Client Application

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - stage
          - prod

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: windows-latest
    environment: ${{ github.event.inputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_TERRAFORM_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get Key Vault URL
        id: get-keyvault
        run: |
          $kvUrl = az keyvault show `
            --name "kv-megabks-trn-mgr-${{ github.event.inputs.environment }}" `
            --resource-group "rg-trn-mgr-${{ github.event.inputs.environment }}" `
            --query "properties.vaultUri" `
            --output tsv
          
          echo "KEYVAULT_URL=$kvUrl" >> $env:GITHUB_ENV
          Write-Host "Key Vault URL: $kvUrl"

      - name: Update appsettings.json
        working-directory: source/main
        run: |
          Write-Host "Updating appsettings.json with Key Vault URL: $env:KEYVAULT_URL"
          
          $appSettings = Get-Content appsettings.json | ConvertFrom-Json
          $appSettings.KeyVaultConfig.VaultUrl = $env:KEYVAULT_URL
          
          $appSettings | ConvertTo-Json -Depth 10 | Set-Content appsettings.json
          
          Write-Host "Updated appsettings.json:"
          Get-Content appsettings.json

      - name: Build application
        working-directory: source/main
        run: |
          dotnet build BowlingMegabucks.TournamentManager.csproj -c Release

      - name: Get application version
        id: get-version
        working-directory: source/main
        run: |
          [xml]$csproj = Get-Content BowlingMegabucks.TournamentManager.csproj
          $version = $csproj.Project.PropertyGroup.VersionPrefix | Where-Object { $_ -ne $null } | Select-Object -First 1
          echo "VERSION=$version" >> $env:GITHUB_ENV
          Write-Host "Application version: $version"

      - name: Publish ClickOnce
        working-directory: source/main
        env:
          INSTALL_URL: ${{ vars.CLICKONCE_INSTALL_URL }}
        run: |
          # First, do a regular publish to get the application files
          dotnet publish BowlingMegabucks.TournamentManager.csproj `
            -c Release `
            -r win-x64 `
            --self-contained false `
            -o publish\app.publish
          
          # Find Mage.exe from Windows SDK
          $magePath = Get-ChildItem -Path "${env:ProgramFiles(x86)}\Windows Kits" -Recurse -Filter "mage.exe" -ErrorAction SilentlyContinue | 
            Where-Object { $_.FullName -like "*\bin\*\x64\mage.exe" } | 
            Select-Object -First 1 -ExpandProperty FullName
          
          if (-not $magePath) {
            Write-Error "Mage.exe not found. ClickOnce tools may not be installed."
            exit 1
          }
          
          Write-Host "Using Mage: $magePath"
          
          $appName = "BowlingMegabucks.TournamentManager"
          $publishPath = "publish\app.publish"
          $deployUrl = "${env:INSTALL_URL}app.publish/"
          
          # Create application manifest
          & $magePath -New Application `
            -ToFile "$publishPath\$appName.exe.manifest" `
            -Name "$appName" `
            -Version "${env:VERSION}.0" `
            -FromDirectory $publishPath `
            -IconFile Resources\NMT.ico
          
          # Sign the application manifest (using a certificate would go here in production)
          # For now, we'll create it without signing
          
          # Create deployment manifest (.application file)
          & $magePath -New Deployment `
            -ToFile "publish\$appName.application" `
            -Name "Tournament Manager" `
            -Version "${env:VERSION}.0" `
            -AppManifest "$publishPath\$appName.exe.manifest" `
            -ProviderUrl $deployUrl `
            -Install true `
            -Publisher "Bowling Megabucks" `
            -UpdateEnabled true `
            -UpdateMode Foreground
          
          # Create setup bootstrapper
          Write-Host "Creating setup.exe bootstrapper"
          $setupPath = "publish\setup.exe"
          Copy-Item "$publishPath\$appName.exe" $setupPath
          
          # Create publish.html
          $html = "<!DOCTYPE html><html><head><title>Tournament Manager - Install</title></head><body><h1>Tournament Manager</h1><p>Click the button below to install the application.</p><a href='$appName.application'>Install Now</a></body></html>"
          Set-Content -Path "publish\publish.html" -Value $html
          
          Write-Host "ClickOnce files generated:"
          Get-ChildItem -Path publish -Recurse -File | Select-Object FullName

      - name: Deploy to FTP Server
        working-directory: source/main/publish
        env:
          FTP_SERVER: ${{ vars.FTP_SERVER }}
          FTP_USERNAME: ${{ secrets.FTP_USERNAME }}
          FTP_PASSWORD: ${{ secrets.FTP_PASSWORD }}
          FTP_FOLDER: ${{ vars.FTP_FOLDER }}
        run: |
          Write-Host "Deploying to FTP Server: $env:FTP_SERVER"
          Write-Host "Target folder: $env:FTP_FOLDER"
          
          # Function to upload file via FTP
          function Upload-FileToFtp {
              param(
                  [string]$LocalPath,
                  [string]$RemotePath,
                  [string]$FtpServer,
                  [string]$Username,
                  [string]$Password
              )
              
              $ftpUri = "ftp://$FtpServer/$RemotePath"
              Write-Host "Uploading: $LocalPath -> $ftpUri"
              
              $ftpRequest = [System.Net.FtpWebRequest]::Create($ftpUri)
              $ftpRequest.Method = [System.Net.WebRequestMethods+Ftp]::UploadFile
              $ftpRequest.Credentials = New-Object System.Net.NetworkCredential($Username, $Password)
              $ftpRequest.UseBinary = $true
              $ftpRequest.UsePassive = $true
              $ftpRequest.KeepAlive = $false
              
              $fileContent = [System.IO.File]::ReadAllBytes($LocalPath)
              $ftpRequest.ContentLength = $fileContent.Length
              
              $requestStream = $ftpRequest.GetRequestStream()
              $requestStream.Write($fileContent, 0, $fileContent.Length)
              $requestStream.Close()
              
              $response = $ftpRequest.GetResponse()
              Write-Host "Upload completed: $($response.StatusDescription)"
              $response.Close()
          }
          
          # Function to create directory via FTP
          function Create-FtpDirectory {
              param(
                  [string]$RemotePath,
                  [string]$FtpServer,
                  [string]$Username,
                  [string]$Password
              )
              
              try {
                  $ftpUri = "ftp://$FtpServer/$RemotePath"
                  Write-Host "Creating directory: $ftpUri"
                  $ftpRequest = [System.Net.FtpWebRequest]::Create($ftpUri)
                  $ftpRequest.Method = [System.Net.WebRequestMethods+Ftp]::MakeDirectory
                  $ftpRequest.Credentials = New-Object System.Net.NetworkCredential($Username, $Password)
                  $ftpRequest.UsePassive = $true
                  $ftpRequest.KeepAlive = $false
                  
                  $response = $ftpRequest.GetResponse()
                  Write-Host "✓ Directory created: $RemotePath"
                  $response.Close()
              }
              catch [System.Net.WebException] {
                  $response = $_.Exception.Response
                  if ($response) {
                      $statusCode = [int]$response.StatusCode
                      # 550 = Directory already exists, which is fine
                      if ($statusCode -eq 550) {
                          Write-Host "✓ Directory already exists: $RemotePath"
                      } else {
                          Write-Host "Warning: Could not create directory $RemotePath - $($_.Exception.Message)"
                      }
                  }
              }
              catch {
                  Write-Host "Warning: Could not create directory $RemotePath - $($_.Exception.Message)"
              }
          }
          
          # Function to ensure full directory path exists
          function Ensure-FtpDirectoryPath {
              param(
                  [string]$RemotePath,
                  [string]$FtpServer,
                  [string]$Username,
                  [string]$Password
              )
              
              # Skip if already processed
              if ($script:createdDirectories -contains $RemotePath) {
                  return
              }
              
              $parts = $RemotePath.Split('/', [StringSplitOptions]::RemoveEmptyEntries)
              $currentPath = ""
              
              foreach ($part in $parts) {
                  if ($currentPath) {
                      $currentPath += "/$part"
                  } else {
                      $currentPath = $part
                  }
                  
                  # Skip if already created
                  if ($script:createdDirectories -contains $currentPath) {
                      continue
                  }
                  
                  Create-FtpDirectory -RemotePath $currentPath -FtpServer $FtpServer -Username $Username -Password $Password
                  $script:createdDirectories += $currentPath
              }
          }
          
          # Cache for created directories
          $script:createdDirectories = @()
          
          # Create target directory
          Ensure-FtpDirectoryPath -RemotePath $env:FTP_FOLDER -FtpServer $env:FTP_SERVER -Username $env:FTP_USERNAME -Password $env:FTP_PASSWORD
          
          # Upload all files
          $files = Get-ChildItem -Recurse -File
          $totalFiles = $files.Count
          $currentFile = 0
          
          foreach ($file in $files) {
              $currentFile++
              $relativePath = $file.FullName.Substring((Get-Location).Path.Length + 1).Replace('\', '/')
              $remotePath = "$env:FTP_FOLDER/$relativePath"
              
              # Create subdirectories if needed
              $remoteDir = ($remotePath -replace '\\', '/').Substring(0, $remotePath.LastIndexOf('/'))
              if ($remoteDir -and $remoteDir -ne $env:FTP_FOLDER) {
                  Ensure-FtpDirectoryPath -RemotePath $remoteDir -FtpServer $env:FTP_SERVER -Username $env:FTP_USERNAME -Password $env:FTP_PASSWORD
              }
              
              Write-Host "[$currentFile/$totalFiles] Uploading $relativePath"
              Upload-FileToFtp -LocalPath $file.FullName -RemotePath $remotePath -FtpServer $env:FTP_SERVER -Username $env:FTP_USERNAME -Password $env:FTP_PASSWORD
          }
          
          Write-Host "Upload successful! Deployed $totalFiles files."
